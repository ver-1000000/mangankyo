{"version":3,"sources":["SplashScreen/SplashScreen.tsx","Settings/Settings.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["SplashScreen","already","h1Ref","React","useRef","useEffect","current","classList","className","title","ref","alt","src","role","toggleModal","dialogPolyfill","registerDialog","open","close","showModal","Settings","scale","setScale","facingMode","setFacingMode","canvasRef","download","dialogRef","scaleRangeInputRef","keydownHandling","useCallback","e","keyCode","preventDefault","keydownHandlingCallback","clickHandling","clickHandlingCallback","toggleFacingModeHandling","toggleFacingModeHandlingCallback","document","addEventListener","style","top","backgroundImage","value","type","step","min","max","defaultValue","onClick","valueAsNumber","href","assertIsDefined","val","alert","Error","errorOnAlert","error","OverconstrainedError","name","message","rad","deg","Math","PI","createCanvas","width","height","canvas","Object","assign","createElement","ctx","getContext","getTriangleCanvas","video","videoWidth","videoHeight","tan","points","x","y","shiftX","shiftY","save","drawImage","restore","globalCompositeOperation","beginPath","moveTo","lineTo","closePath","fill","getPatternCanvasContext","triangle","setPatternCanvas","drawTransform","transform","rotate","scaleY","translateX","translateY","setTransform","translate","createPattern","getWebcamStream","a","srcObject","MediaStream","getTracks","forEach","track","stop","navigator","mediaDevices","getUserMedia","audio","catch","play","setAlready","getBoundingClientRect","update","triangleCanvas","fillStyle","fillRect","paused","requestAnimationFrame","then","downloadCallback","pattern","options","anchor","img","body","appendChild","toDataURL","Date","toLocaleString","year","month","day","hour","minute","second","replace","click","remove","VIDEO","internalVideo","attr","setAttribute","App","useState","patternCanvas","streamPromise","pause","startPlayCallback","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","getElementById","serviceWorker","ready","registration","unregister","console"],"mappings":"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","file":"static/js/main.e22b00a0.chunk.js","sourcesContent":["import React from 'react';\n\nimport './SplashScreen.css';\n\nconst SplashScreen = ({ already }: { already: boolean }) => {\n  const h1Ref = React.useRef<HTMLHeadingElement>(null);\n  React.useEffect(() => h1Ref.current?.classList[already ? 'add' : 'remove']('loaded'), [already]);\n  return (\n    <h1 className=\"SplashScreen-h1\" title=\"万顔鏡\" ref={h1Ref}>\n      <img className=\"SplashScreen-img-logo\" alt=\"万顔鏡 ロゴ画像\" src=\"./splash-logo.svg\" />\n      <img className=\"SplashScreen-img-star\" alt=\"\" role=\"presentation\" src=\"./splash-star.svg\" />\n    </h1>\n  );\n};\n\nexport default SplashScreen;\n","import React from 'react';\nimport dialogPolyfill from 'dialog-polyfill';\n\nimport { DownloadOptions } from '../App';\nimport './Settings.css';\n\ninterface Props {\n  already: boolean;\n  className: string;\n  canvasRef: React.RefObject<HTMLCanvasElement>;\n  scale: number;\n  setScale: React.Dispatch<React.SetStateAction<number>>;\n  facingMode: MediaTrackConstraints['facingMode'];\n  setFacingMode: React.Dispatch<React.SetStateAction<this['facingMode']>>;\n  download: (option: DownloadOptions) => void;\n}\n\n/**\n * モーダルの表示状態を切り替える。\n */\nconst toggleModal = ({ current }: React.RefObject<HTMLDialogElement>) => {\n  if (current == null) { return; }\n  dialogPolyfill.registerDialog(current);\n  if (current.open) {\n    current.close();\n  } else {\n    current.showModal();\n  }\n};\n\n/**\n * キーダウンイベントの取り回し。 ESC押下時にモーダルの表示状態を切り替える。\n */\nconst keydownHandlingCallback = (dialogRef: React.RefObject<HTMLDialogElement>) => (e: KeyboardEvent) => {\n  if (e.keyCode === 27) { // Escape\n    e.preventDefault();\n    toggleModal(dialogRef);\n  }\n};\n\n/**\n * クリックイベントの取り回し。 モーダルの表示状態を切り替える。\n */\nconst clickHandlingCallback = (dialogRef: React.RefObject<HTMLDialogElement>) => () => {\n  toggleModal(dialogRef);\n};\n\n/**\n * フロントカメラ / リアカメラを切り替える。\n */\nconst toggleFacingModeHandlingCallback = (\n  setFacingMode: React.Dispatch<React.SetStateAction<MediaTrackConstraints['facingMode']>>,\n  facingMode:  MediaTrackConstraints['facingMode']\n) => () => {\n  setFacingMode(facingMode === 'user' ? 'environment' : 'user');\n}\n\nconst Settings = ({ already, scale, setScale, facingMode, setFacingMode, canvasRef, download }: Props) => {\n  const dialogRef                = React.useRef<HTMLDialogElement>(null);\n  const scaleRangeInputRef       = React.useRef<HTMLInputElement>(null);\n  const keydownHandling          = React.useCallback(keydownHandlingCallback(dialogRef), []);\n  const clickHandling            = React.useCallback(clickHandlingCallback(dialogRef), []);\n  const toggleFacingModeHandling = React.useCallback(toggleFacingModeHandlingCallback(setFacingMode, facingMode), []);\n\n  React.useEffect(() => document.addEventListener('keydown', keydownHandling, false), [keydownHandling]);\n  React.useEffect(() => canvasRef.current?.addEventListener('click', clickHandling, false), [clickHandling, canvasRef]);\n\n  if (!already) { return null; }\n\n  return (\n    <>\n      <dialog className=\"Settings-dialog\" ref={dialogRef} style={{top: '30px', backgroundImage: 'url(./splash-star.svg)'}}>\n        <section>\n          <h2>設定</h2>\n          <dl>\n            <dt>パターンの大きさ</dt>\n            <dd>\n              <output>{scaleRangeInputRef.current?.value}</output>\n            </dd>\n            <dd>\n              <input\n                type=\"range\"\n                step=\"0.1\"\n                min=\"0.1\"\n                max=\"2.0\"\n                defaultValue={scale}\n                ref={scaleRangeInputRef}\n              />\n            </dd>\n            <dd>\n              <button type=\"button\" onClick={() => setScale(scaleRangeInputRef.current?.valueAsNumber || 0.5)}>\n                適用する\n              </button>\n            </dd>\n          </dl>\n          <dl>\n            <dt>フロントカメラ / リアカメラ</dt>\n            <dd>\n              <small>※ デバイスが認識できない場合は切り替わりません。</small>\n              <button type=\"button\" onClick={toggleFacingModeHandling}>切り替える</button>\n            </dd>\n          </dl>\n        </section>\n        <section>\n          <h2>ダウンロード</h2>\n          <dl>\n            <dt>表示されているキャンバス画像を保存</dt>\n            <dd>\n              <button type=\"button\" onClick={() => download({ type: 'display' })}>画面全体</button>\n            </dd>\n            <dd>\n              <button type=\"button\" onClick={() => download({ type: 'pattern' })}>最小パターン</button>\n            </dd>\n          </dl>\n        </section>\n        <section>\n          <h2>万顔鏡について</h2>\n          <dl>\n            <dt>Source on GitHub</dt>\n            <dd><a href=\"https://github.com/ver-1000000/mangankyo\">mangankyo</a></dd>\n          </dl>\n          <dl>\n            <dt>WebSite / Author</dt>\n            <dd>\n              <a href=\"https://ver1000000.com\">Ver.1000000</a> / <a href=\"https://twitter.com/Ver1000000000\">@Ver1000000000</a>\n            </dd>\n          </dl>\n        </section>\n        <footer className=\"Settings-footer\">\n          <button type=\"button\" className=\"sky\" onClick={clickHandling}>close</button>\n        </footer>\n      </dialog>\n    </>\n  );\n};\n\nexport default Settings;\n","import React from 'react';\n\nimport './App.css';\nimport SplashScreen from './SplashScreen/SplashScreen';\nimport Settings from './Settings/Settings';\n\n/**\n * ダウンロード時のオプション。\n */\nexport interface DownloadOptions {\n  /** *\"display\"時は画面全体を、\"pattern\"時は最小パターンをダウンロードする。 */\n  type: 'display' | 'pattern';\n}\n\n/**\n * `play`関数に渡すオプション。\n */\ninterface PlayOptions {\n  video: HTMLVideoElement;\n  canvas: HTMLCanvasElement | null;\n  scale: number;\n  setAlready: React.Dispatch<boolean>;\n  setPatternCanvas: React.Dispatch<HTMLCanvasElement>;\n  facingMode: MediaTrackConstraints['facingMode'];\n}\n\n/**\n * 引数がNullableならエラーを投げるアサーション関数。\n */\nfunction assertIsDefined<T>(val: T): asserts val is NonNullable<T> {\n  if (val == null) {\n    alert('レンダリングエラー: ページを再読込してください。');\n    throw new Error(`Expected 'val' to be defined, but received ${val}`);\n  }\n}\n\n/**\n * エラーハンドリング用関数。\n */\nconst errorOnAlert = (error: Error) => {\n  if (error instanceof OverconstrainedError) {\n    alert(`${error.name}:\\n要求されたデバイスが見つかりません。\\n設定を変更してください。`)\n  } else {\n    alert(`${error.name}:\\n${error.message}`);\n  }\n  return null;\n}\n\n/**\n * 現在時刻を取得するお助け関数。\n */\nconst now = () => new Date().toLocaleString('ja-JP', {\n  year: 'numeric',\n  month: '2-digit',\n  day: '2-digit',\n  hour: '2-digit',\n  minute: '2-digit',\n  second: 'numeric'\n}).replace(/\\D/g, '');\n\n/**\n * 度（deg）を受け取ってラジアン角として返却するお助け関数。\n */\nconst rad = (deg: number) => deg * Math.PI / 180;\n\n/**\n * width/heightを設定したHTMLCanvasElement/CanvasRenderingContext2Dを返すお助け関数。\n */\nconst createCanvas = ({ width, height }: { width: number, height: number }) => {\n  const canvas = Object.assign(document.createElement('canvas'), { width, height });\n  const ctx    = canvas.getContext('2d') as CanvasRenderingContext2D;\n  return [canvas, ctx] as const;\n};\n\n/**\n * videoから正三角形に切り抜かれた基準となるcanvasを返す。\n */\nconst getTriangleCanvas = (video: HTMLVideoElement, { scale }: { scale: number }) => {\n  const width         = Math.min(video.videoWidth, video.videoHeight) * scale;\n  const height        = width / 2 * Math.tan(rad(60)); // 正三角形の高さ\n  const [canvas, ctx] = createCanvas({ width, height });\n  const points        = [{ x: width / 2, y: 0 }, { x: width, y: height }, { x: 0, y: height }];\n  const shiftX        = -Math.max(0, (video.videoWidth - video.videoHeight) / 2);\n  const shiftY        = -Math.max(0, (video.videoHeight - video.videoWidth) / 2);\n  ctx.save();\n  ctx.scale(scale, scale);\n  ctx.drawImage(video, shiftX, shiftY, video.videoWidth, video.videoHeight);\n  ctx.restore();\n  ctx.globalCompositeOperation = 'destination-in';\n  ctx.beginPath();\n  ctx.moveTo(points[0].x, points[0].y);\n  ctx.lineTo(points[1].x, points[1].y);\n  ctx.lineTo(points[2].x, points[2].y);\n  ctx.closePath();\n  ctx.fill();\n  ctx.globalCompositeOperation = 'source-over';\n  return canvas;\n};\n\n/**\n * シームレス化されたパターン用のCanvasRenderingContext2Dを返す。\n */\nconst getPatternCanvasContext = (triangle: HTMLCanvasElement, setPatternCanvas: React.Dispatch<HTMLCanvasElement>) => {\n  const [canvas, ctx] = createCanvas({ width: triangle.width * 3, height: triangle.height * 2 });\n  const drawTransform = (transform: { rotate?: number, scaleY?: number, translateX?: number, translateY?: number }) => {\n    const { rotate = 0, scaleY = 1, translateX = 0, translateY = 0 } = transform;\n    ctx.setTransform(1, 0, 0, 1,  canvas.width / 3, canvas.height / 2);\n    ctx.rotate(rad(rotate));\n    ctx.scale(1, scaleY);\n    ctx.translate(translateX, translateY);\n    ctx.drawImage(triangle, -canvas.width / 3, -canvas.height / 2);\n  }\n  drawTransform({ rotate: 0,   scaleY: 1 });\n  drawTransform({ rotate: 0,   scaleY: -1 });\n  drawTransform({ rotate: 0,   scaleY: 1,  translateX: triangle.width * 1.5, translateY: triangle.height });\n  drawTransform({ rotate: 0,   scaleY: -1, translateX: triangle.width * 1.5, translateY: triangle.height });\n  drawTransform({ rotate: 120, scaleY: 1 });\n  drawTransform({ rotate: 120, scaleY: -1 });\n  drawTransform({ rotate: 120, scaleY: 1,  translateX: 0,                    translateY: -triangle.height * 2 });\n  drawTransform({ rotate: 120, scaleY: -1, translateX: 0,                    translateY: triangle.height * 2 });\n  drawTransform({ rotate: 120, scaleY: 1,  translateX: triangle.width * 1.5, translateY: triangle.height });\n  drawTransform({ rotate: 240, scaleY: 1 });\n  drawTransform({ rotate: 240, scaleY: -1 });\n  drawTransform({ rotate: 240, scaleY: 1,  translateX: 0,                    translateY: triangle.height * 2 });\n  drawTransform({ rotate: 240, scaleY: -1, translateX: 0,                    translateY: -triangle.height * 2 });\n  drawTransform({ rotate: 240, scaleY: -1, translateX: triangle.width * 1.5, translateY: triangle.height });\n  setPatternCanvas(canvas);\n  return ctx.createPattern(ctx.canvas, 'repeat')!;\n};\n\n/**\n * WebカメラのMediaStreamを返す。 初期化処理も行う。\n */\nconst getWebcamStream = async (video: HTMLVideoElement, facingMode: MediaTrackConstraints['facingMode']) => {\n   // モバイルでは新しいストリームを取得する前に、trackをすべてstopする必要がある\n  if (video.srcObject instanceof MediaStream) { video.srcObject.getTracks().forEach(track => track.stop()); }\n  return navigator.mediaDevices.getUserMedia({ audio: false, video: { facingMode } }).catch(errorOnAlert);\n};\n\n/**\n * MediaStreamを読み取り、requestAnimationFrameによるイベントループを開始する。\n */\nconst play = async (video: HTMLVideoElement, { canvas, scale, facingMode, setPatternCanvas, setAlready }: PlayOptions) => {\n  assertIsDefined(canvas);\n  video.srcObject         = await getWebcamStream(video, facingMode);\n  const ctx               = canvas.getContext('2d') as CanvasRenderingContext2D;\n  const { width, height } = canvas.getBoundingClientRect();\n  Object.assign(canvas, { width, height });\n  const update = () => {\n    const triangleCanvas   = getTriangleCanvas(video, { scale });\n    ctx.fillStyle          = getPatternCanvasContext(triangleCanvas, setPatternCanvas);\n    ctx.fillRect(0, 0, width, height);\n    if (!video.paused) { requestAnimationFrame(update); }\n  };\n  await video.play().then(() => update()).then(() => setAlready(true));\n  return video.srcObject;\n};\n\n/**\n * 渡されたcanvasからpngを生成し、ダウンロードさせる。\n * {@param pattern} options.typeが\"pattern\"のとき、`pattern`のwidth/heightを利用して`main`を切り抜く\n */\nconst downloadCallback = (\n  canvasRef: React.RefObject<HTMLCanvasElement>,\n  pattern: HTMLCanvasElement | null\n) => (options: DownloadOptions) => {\n  assertIsDefined(canvasRef.current);\n  assertIsDefined(pattern);\n  const { width, height } = options.type === 'display' ? canvasRef.current : pattern;\n  const [canvas, ctx] = createCanvas({ width, height });\n  ctx.drawImage(canvasRef.current, 0, 0);\n  const anchor = document.createElement('a');\n  const img    = document.createElement('img');\n  document.body.appendChild(anchor);\n  document.body.appendChild(img);\n  anchor.href     = img.src = canvas.toDataURL()\n  anchor.download = `mangankyo_${now()}.png`;\n  anchor.click();\n  anchor.remove();\n  img.remove();\n};\n\n/**\n * オンメモリー上でAPIを提供し続けるためのvideo。\n */\nconst VIDEO = (() => {\n  const internalVideo = document.createElement('video');\n  ['playsinline', 'muted', 'autoplay'].forEach(attr => internalVideo.setAttribute(attr, '')); // Mobile Safariでの再生に必須\n  return internalVideo;\n})();\n\n/**\n * 値の変更に連動し、videoの再生と停止などを行う。\n */\nconst startPlayCallback = ({\n  video,\n  canvasRef,\n  scale,\n  facingMode,\n  setPatternCanvas,\n  setAlready\n}: Omit<PlayOptions, 'canvas'> & { canvasRef: React.RefObject<HTMLCanvasElement> }) => () => {\n  if (typeof navigator.mediaDevices?.getUserMedia !== `function`) {\n    errorOnAlert(new Error('お使いのブラウザはgetUserMedia()に未対応です。\\n他のブラウザをご利用ください。'));\n    return;\n  }\n  const streamPromise = play(video, { video, canvas: canvasRef.current, scale, facingMode, setPatternCanvas, setAlready });\n  return () => {\n    setAlready(false);\n    streamPromise.then(() => video.paused || video.pause()).then(() => setAlready(true));\n  };\n};\n\nconst App = () => {\n  const [already, setAlready]             = React.useState<boolean>(false);\n  const [facingMode, setFacingMode]       = React.useState<PlayOptions['facingMode']>('user');\n  const [scale, setScale]                 = React.useState<number>(0.5);\n  const [patternCanvas, setPatternCanvas] = React.useState<HTMLCanvasElement | null>(null);\n  const canvasRef                         = React.useRef<HTMLCanvasElement>(null);\n  const download                          = React.useCallback(downloadCallback(canvasRef, patternCanvas), [patternCanvas]);\n  const video                             = VIDEO;\n  React.useEffect(startPlayCallback({\n    video,\n    canvasRef,\n    scale,\n    facingMode,\n    setPatternCanvas,\n    setAlready\n  }), [scale, facingMode]);\n\n  return (\n    <>\n      <canvas ref={canvasRef} className=\"App-canvas\"></canvas>\n      <SplashScreen already={already} />\n      <Settings\n        className=\"App-Settings\"\n        already={already}\n        scale={scale}\n        setScale={setScale}\n        facingMode={facingMode}\n        setFacingMode={setFacingMode}\n        download={download}\n        canvasRef={canvasRef}\n      />\n    </>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}